
## 第02周-零基础-高级-项目实战最新教程-共14章节  

介绍、基本语法、流程控制  

### 目录  

[第01章节-本节鸡汤](#第01章节-本节鸡汤)  
[第02章节-模块初识](#第02章节-模块初识)  
[第03章节-模块初识2](#第03章节-模块初识2)  
[第04章节-pyc是什么](#第04章节-pyc是什么)  
[第05章节-python数据类型](#第05章节-python数据类型)  
[第06章节-bytes数据类型](#第06章节-bytes数据类型)  
[第07章节-列表的使用](#第07章节-列表的使用)  
[第08章节-列表的使用2](#第08章节-列表的使用2)  
[第09章节-元组与购物车程序练习](#第09章节-元组与购物车程序练习)  
[第10章节-购物车程序练习实例](#第10章节-购物车程序练习实例)  
[第11章节-字符串常用操作](#第11章节-字符串常用操作)  
[第12章节-字典的使用](#第12章节-字典的使用)  
[第13章节-三级菜单实例](#第13章节-三级菜单实例)  
[第14章节-本周作业-购物车优化](#第14章节-本周作业-购物车优化)  


#### 第01章节-本节鸡汤  

#### 第02章节-模块初识  
Python中出有标准库(无需安装))之外还有第三方库。第三方库使用前需要下载安装。  

标准库sys os模块：  

[systest.py](../../codes/Python-S14/week02/systest.py)  
```python{.line-numbers}  
#systest.py
import sys
print(sys.path) #sys.path 环境变量
print(sys.argv) #文件输入参数

```
```python{.line-numbers}  
#本地电脑上的输出路径
['f:\\LinuxOperation\\codes\\Python-S14\\week02',
 'E:\\Anaconda3\\python37.zip', 
 'E:\\Anaconda3\\DLLs', 
 'E:\\Anaconda3\\lib', 
 'E:\\Anaconda3', 
 'E:\\Anaconda3\\lib\\site-packages',
 'E:\\Anaconda3\\lib\\site-packages\\win32', 
 'E:\\Anaconda3\\lib\\site-packages\\win32\\lib', 
 'E:\\Anaconda3\\lib\\site-packages\\Pythonwin']
```
`lib/site-packages` 一般安装的第三方库都在这里。`lib`下面的诸多`py`文件，就是标准库。  

```python{.line-numbers}
#systest.py  
import os
#cmd_res = os.system("dir") #执行命令，不保存
cmd_res = os.popen("dir") 
#cmd_res = os.popen("dir") 返回的是对象的内存地址
#需要再次的引用 read把结果读取出来
cmd_res = os.popen("dir").read()
print(cmd_res)

os.mkdir("new_dir") #创建目录
```
#### 第03章节-模块初识2  

```python{.line-numbers}
#导入自己写的模块
import XXX
```
使用自己写的模块的导入有两种方法：1. 放到`lib/site-packages` 目录下; 2. 加入环境变量中，也就是添加一个路径;  

返回: [目录](#目录)  

#### 第04章节-pyc是什么  

`python`是一个解释性语言，但是存在`pyc`文件。
`编译型语言`会在执行之前，执行一个编译的过程。程序会被转换成机器语言。运行时候不需要翻译，可以直接执行。  
`解释型`语言不要编译这个过程。  

但是，也存在一些解释型语言，通过解释器的优化在对程序作出翻译时，对整个程序作出优化，但是速度不太可能超过编译型语言的，最多近似。  

用`Java`来举例，`Java` 首先是通过编译器编译成字节码文件，然后在运行时通过解释器给解释成机器文件。可以将`Java`当成一种先编译后解释的语言。  

`Python`也是一门基于虚拟机的语言。也有类似Java的先编译后解释过程。但是这个过程不对使用者公开。  

有两个概念 `PyCodeObject` 和 `pyc` 文件，`PyCodeObject`是Python编译真正的编译结果。当Python运行的时候，编译的结果是保存在内存中`PyCodeObject` 中，当Python程序运行结束的时，Python解释器将`PyCodeObject`写回到 `pyc` 文件中。  

当Python程序第二次运行时，首先程序会先找pyc文件。如果有，直接载入。没有就重复上面的过程。  

所以，`pyc`文件实际上是`PyCodeObject`的一种持久化保存方式，一种`字节码`文件。   

返回: [目录](#目录)  

#### 第05章节-python数据类型  
#### 第06章节-bytes数据类型  

《[Python3的bytes/str之别](https://www.cnblogs.com/txw1958/archive/2012/07/19/2598885.html)》  
《[The bytes/str dichotomy in Python 3》](https://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3/)》  

网络编程中，所有的内容都必须要转成二进制。  

```python{.line-numbers}
msg = "我爱北京天安门"
print(msg)
print(msg.encode()) #不强调就使用系统默认编码，默认'utf-8'
print(msg.encode(encoding="utf-8"))
print(msg.encode(encoding="utf-8").decode(encoding="utf-8"))
```
返回: [目录](#目录)  

#### 第07章节-列表的使用  
 
```python{.line-numbers}
names = ["Zhang","Li","Wang","Qian"]
print(names[0:2]) #切片
print(names[-1])  #最后一个
print(names[-2:]) #最后两个
print(names[:3])  #前三个，0可以忽略
names.append("ll") #末尾添加
names.insert(1,"ChenRonghua") #指定位置添加
names.remove("ChenRonghua")   #移除相关内容
```
注意在取连续个数的时候，name[0:2]，实际上拿到的是0，1这两个列表元素。可以理解为“顾头不顾尾”。  

返回: [目录](#目录)  

